[java/command/AddCommand.java]:

package seedu.command;

import seedu.exceptions.InventraException;
import seedu.exceptions.InventraInvalidFlagException;
import seedu.exceptions.InventraInvalidRecordCountException;
import seedu.exceptions.InventraInvalidTypeException;
import seedu.exceptions.InventraMissingArgsException;
import seedu.exceptions.InventraMissingFieldsException;
import seedu.exceptions.InventraNegativeValueException;
import seedu.model.Inventory;
import seedu.storage.Csv;
import seedu.ui.Ui;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class AddCommand extends Command {
    private static final Logger LOGGER = Logger.getLogger(AddCommand.class.getName());

    static {
        try {
            // Set up FileHandler to log messages to "app.log"
            FileHandler fileHandler = new FileHandler("app.log", true); // Appends to "app.log"
            fileHandler.setFormatter(new SimpleFormatter()); // Simple text formatter

            // Add FileHandler to the logger
            LOGGER.addHandler(fileHandler);

            // Disable logging to the console
            LOGGER.setUseParentHandlers(false);
        } catch (IOException e) {
            e.printStackTrace(); // Print exception if file handler fails to set up
        }
    }

    public AddCommand(Inventory inventory, Ui ui, Csv csv) {
        super(inventory, ui, csv);
    }

    public void execute(String[] args) throws InventraException {
        if (args.length < 2) {
            throw new InventraMissingArgsException("flag");
        }
        String flag = args[1];
        switch (flag) {
        case "-h":
            if (args.length < 3) {
                throw new InventraMissingArgsException("field data for flag -h");
            }
            handleAddMultipleFields(args[2]);
            csv.updateCsvHeaders(inventory);
            break;

        case "-d":
            assert args.length >= 3 : "Expected record data for flag -d";
            handleAddRecord(args[2]);
            csv.appendRecord(inventory.getRecords().get(inventory.getRecords().size() - 1), inventory);
            break;

        default:
            throw new InventraInvalidFlagException("Use 'add -h <fields>' 'add -l', or 'add -d <values>'");
        }
    }

    private void handleAddMultipleFields(String fieldData) throws InventraException {
        if (fieldData.isEmpty()) {
            throw new InventraMissingFieldsException();
        }

        String[] newFields = fieldData.split(",\\s*");

        for (String field : newFields) {
            String[] parts = field.split("/");
            if (parts.length != 2) {
                throw new InventraInvalidTypeException("Field format", field, "correct format (type/fieldName)");
            }

            String type = parts[0].trim();
            String fieldName = parts[1].trim();

            // Check if the field name is empty or contains only spaces
            if (fieldName.isEmpty()) {
                throw new InventraInvalidTypeException(fieldName, "cannot " +
                        "be empty or just spaces", "provide a valid field name");
            }

            if (fieldName.length() > 20) {
                throw new InventraInvalidTypeException(fieldName, "length exceeds 20 characters", "shorter name");
            }

            if (!isValidFieldType(type)) {
                throw new InventraInvalidTypeException(fieldName, type, "valid field type (e.g., 's', 'i', 'f', 'd')");
            }

            if (inventory.getFields().contains(fieldName)) {
                throw new InventraInvalidTypeException(fieldName, "duplicate field", "Field already exists");
            }

            inventory.addField(fieldName, type);
        }

        ui.showSuccessFieldsAdded();
        ui.showFieldsAndRecords(inventory);
    }


    private void handleAddRecord(String recordData) throws InventraException {
        LOGGER.info("Handling add record: " + recordData);

        if (inventory.getFields().isEmpty()) {
            throw new InventraMissingFieldsException();
        }

        String[] values = recordData.split(",\\s*");

        if (values.length != inventory.getFields().size()) {
            throw new InventraInvalidRecordCountException(inventory.getFields().size(), values.length);
        }

        Map<String, String> record = new HashMap<>();
        for (int i = 0; i < values.length; i++) {
            String field = inventory.getFields().get(i);
            String type = inventory.getFieldTypes().get(field);

            assert type != null : "Type for field '" + field + "' should not be null";

            String value = values[i].trim();

            // Check if the value is empty or contains only spaces
            if (value.isEmpty()) {
                throw new InventraInvalidTypeException(field, "cannot " +
                        "be empty or just spaces", "provide a valid value for the record");
            }

            if (value.length() > 20) {
                throw new InventraInvalidTypeException(field, value, "length " +
                        "exceeds 20 characters");
            }

            String validationMessage = validateValue(value, type, field);
            if (validationMessage != null) {
                ui.showValidationError(validationMessage);
                return;
            }

            record.put(field, value);
        }

        inventory.addRecord(record);
        ui.showSuccessRecordAdded();
    }


    public String validateValue(String value, String type, String field) throws InventraException {
        assert value != null && !value.isEmpty() : "Value should not be null or empty";
        assert type != null && !type.isEmpty() : "Field type should not be null or empty";
        assert field != null && !field.isEmpty() : "Field name should not be null or empty";

        switch (type) {
        case "s": // String
            return null; // Any string is valid
        case "i": // Integer
            try {
                int intValue = Integer.parseInt(value);
                if (intValue < 0) {
                    throw new InventraNegativeValueException(field, value);
                }
                return null; // Valid integer
            } catch (NumberFormatException e) {
                throw new InventraInvalidTypeException(field, value, "integer");
            }
        case "f": // Float
            try {
                float floatValue = Float.parseFloat(value);
                if (floatValue < 0) {
                    throw new InventraNegativeValueException(field, value);
                }
                return null; // Valid float
            } catch (NumberFormatException e) {
                throw new InventraInvalidTypeException(field, value, "float");
            }
        case "d": // Date
            String[] parts = value.split("/");
            if (parts.length != 3) {
                throw new InventraInvalidTypeException(
                        field,
                        value,
                        "date (expected format: DD/MM/YYYY or DD/MM/YY)"
                );
            }
            try {
                int day = Integer.parseInt(parts[0]);
                int month = Integer.parseInt(parts[1]);
                int year = Integer.parseInt(parts[2]);
                if (day <= 0 || day > 31 || month <= 0 || month > 12 || year < 0) {
                    throw new InventraInvalidTypeException(field, value, "valid date in DD/MM/YYYY or DD/MM/YY format");
                }
                return null; // Valid date
            } catch (NumberFormatException e) {
                throw new InventraInvalidTypeException(field, value, "valid date (DD/MM/YYYY or DD/MM/YY)");
            }
        case "n": // Null
            if (!value.equalsIgnoreCase("null")) {
                throw new InventraInvalidTypeException(field, value, "null");
            }
            return null; // Valid null
        default:
            return ui.getUnknownTypeMessage(field);
        }
    }

    private boolean isValidFieldType(String type) {
        return type.equals("s") || type.equals("i") || type.equals("f") || type.equals("d");
    }
}


[java/command/Command.java]:

package seedu.command;

import seedu.model.Inventory;
import seedu.ui.Ui;
import seedu.storage.Csv;
import seedu.exceptions.InventraException;

public abstract class Command {
    protected Inventory inventory;
    protected Ui ui;
    protected Csv csv;

    public Command(Inventory inventory, Ui ui, Csv csv) {
        this.inventory = inventory;
        this.ui = ui;
        this.csv = csv;
    }

    public Inventory getInventory() {
        return inventory;
    }

    public Ui getUi() {
        return ui;
    }

    public Csv getCsv() {
        return csv;
    }

    public abstract void execute(String[] args) throws InventraException;
}


[java/command/DeleteCommand.java]:

package seedu.command;

import seedu.exceptions.InventraException;
import seedu.exceptions.InventraInvalidFlagException;
import seedu.exceptions.InventraInvalidNumberException;
import seedu.exceptions.InventraMissingArgsException;
import seedu.exceptions.InventraOutOfBoundsException;
import seedu.model.Inventory;
import seedu.ui.Ui;
import seedu.storage.Csv;

import java.util.List;
import java.util.Map;

public class DeleteCommand extends Command {

    public DeleteCommand(Inventory inventory, Ui ui, Csv csv) {
        super(inventory, ui, csv);
    }

    public void execute(String[] args) throws InventraException {
        if (args.length < 2) {
            throw new InventraMissingArgsException("Record Number");
        }

        String part = args[1].trim();
        if (part.isEmpty()) {
            throw new InventraMissingArgsException("Record Number");
        }
        if (!part.startsWith("-")) {
            int index = parseIndex(part);
            deleteSingleRecord(index);
            ui.printMessage("Record deleted successfully.");
        } else {
            switch (part) {
            case "-e":
                deleteEntireTable();
                ui.printMessage("Deleted entire table.");
                break;
            case "-a":
                deleteAllRecords();
                ui.printMessage("Deleted all records.");
                break;
            case "-h":
                if (args.length < 3 || args[2].trim().isEmpty()) {
                    throw new InventraMissingArgsException("Field name");
                }
                deleteHeaderAndColumn(args[2].trim());
                ui.printMessage("Deleted header and it's column.");
                break;
            case "-r":
                if (args.length < 3 || args[2].trim().isEmpty()) {
                    throw new InventraMissingArgsException("Range");
                }
                String[] numbers = args[2].trim().split("-");
                if (numbers.length != 2) {
                    throw new InventraInvalidFlagException("Invalid range format. Expected format: <start>-<end>");
                }
                deleteRangeRecords(parseIndex(numbers[0]), parseIndex(numbers[1]));
                break;
            default:
                throw new InventraInvalidFlagException("use 'help delete' to receive details about all " +
                        "available flags and their functions");
            }
        }

    }

    private void deleteEntireTable() {
        inventory.getFields().clear();
        inventory.getFieldTypes().clear();
        deleteAllRecords();
        csv.updateCsvAfterDeletion(inventory); // Update the CSV file to reflect the empty table
    }

    private boolean isWithinBounds(int index, int size) {
        return (index > 0 && index <= size);
    }

    private void deleteRangeRecords(int start, int end) throws InventraOutOfBoundsException {
        List<Map<String, String>> records = inventory.getRecords();
        if (!isWithinBounds(start, records.size())) {
            throw new InventraOutOfBoundsException(start, 1, records.size());
        }
        if (!isWithinBounds(end, records.size())) {
            throw new InventraOutOfBoundsException(end, 1, records.size());
        }
        if (end >= start) {
            inventory.getRecords().subList(start - 1, end).clear();
            csv.updateCsvAfterDeletion(inventory);
        }
    }

    private void deleteAllRecords() {
        inventory.getRecords().clear();
        csv.updateCsvAfterDeletion(inventory); // Update the CSV file to reflect the empty records
    }

    private void deleteHeaderAndColumn(String fieldName) throws InventraInvalidFlagException {
        if (!inventory.getFields().contains(fieldName)) {
            throw new InventraInvalidFlagException("Header '"
                    + fieldName + "' does not exist.");
        }
        inventory.getFields().remove(fieldName);
        inventory.getFieldTypes().remove(fieldName);

        for (Map<String, String> record : inventory.getRecords()) {
            record.remove(fieldName);
        }
        csv.updateCsvAfterDeletion(inventory);
    }

    private int parseIndex(String indexString) throws InventraInvalidNumberException, InventraInvalidFlagException {
        if (indexString.contains(",") || indexString.contains("-")) {
            throw new InventraInvalidFlagException("Invalid flag or range format: "
                    + indexString);
        }
        try {
            return Integer.parseInt(indexString);
        } catch (NumberFormatException e) {
            throw new InventraInvalidNumberException("Error: The input "
                    + indexString + " could not be parsed as an integer.");
        }
    }

    private void deleteSingleRecord(int recordIndex) throws InventraOutOfBoundsException {
        List<Map<String, String>> records = inventory.getRecords();

        if (isWithinBounds(recordIndex, records.size())) {
            records.remove(recordIndex - 1); // Convert to zero based indexing
            csv.updateCsvAfterDeletion(inventory);
        } else {
            throw new InventraOutOfBoundsException(recordIndex, 1, records.size());
        }
    }
}


[java/command/HelpCommand.java]:

package seedu.command;

import java.util.LinkedHashMap;
import java.util.Map;
import seedu.ui.Ui;

public class HelpCommand extends Command {

    private final Map<String, String> helpMessages;

    public HelpCommand(Ui ui) {
        super(null, ui, null); // Inventory and Csv are not needed here
        helpMessages = new LinkedHashMap<>();

        // Add help messages for each command
        helpMessages.put("view",
                "View records:\n" +
                        "   - Command to view all items: view -a\n" +
                        "   - Command to view specific item by ID: view <ID>\n" +
                        "   - Example: view 1\n" +
                        "   - Command to find specific item by string: view -f <STRING>\n" +
                        "   - Example: view -f Apple\n");

        helpMessages.put("add -h",
                "Add custom fields with specific types:\n" +
                        "Note: Types: s - String, i - Integer, f - Float, d - Date\n" +
                        "   - Command: add -h <type/field, type/field, ...>\n" +
                        "   - Example: add -h s/name, i/quantity, f/price\n");

        helpMessages.put("add -d",
                "Add Records to custom fields created:\n" +
                        "   - Command: add -d <value1, value2, ...>\n" +
                        "   - Example: add -d Apple, 100, 1.50, 01/10/2024\n" +
                        "   - Note: Date format must be DD/MM/YYYY or DD/MM/YY\n" +
                        "   - Example: add -d Apple, 100, 1.50, 01/10/2024\n");

        helpMessages.put("delete",
                "Delete Specific Records:\n" +
                        "   - Command: delete <record number>\n" +
                        "   - Example: delete 2\n");

        helpMessages.put("delete -a",
                "Delete All Records:\n" +
                        "   - Command: delete -a\n");

        helpMessages.put("delete -e",
                "Delete Entire Table:\n" +
                        "   - Command: delete -e\n");

        helpMessages.put("delete -h",
                "Delete a header and its corresponding column:\n" +
                        "   - Command: delete -h <header_name>\n");

        helpMessages.put("delete -r",
                "Delete a range of records using index range:\n" +
                        "   - Command: delete -r <start_index>-<end_index>\n");

        helpMessages.put("update",
                "Update Records or Fields:\n" +
                        "   - Update a record: update -d <index_number>,<field_name>,<new_value>\n" +
                        "   - Example: update -d 1,name,Orange\n" +
                        "   - Update a header: update -h <old_header_name>,<new_header_name>\n" +
                        "   - Example: update -h name,product_name\n");

        helpMessages.put("exit",
                "Exit program:\n" +
                        "   - Command: exit\n");
    }

    public void execute(String[] parts) {
        if (parts.length < 2) {
            int i = 1;
            for (String command : helpMessages.keySet()) {
                System.out.printf("%d. %s\n", i, helpMessages.get(command));
                i += 1;
            }
            return;
        }
        String command = parts[1];
        if (parts.length > 2) {
            command += " " + parts[2];
        }

        switch (command) {
        case "view":
            System.out.println(helpMessages.get("view"));
            break;

        case "add":
        case "add -h":
        case "add -l":
        case "add -d":
            System.out.println(helpMessages.get("add -h"));
            System.out.println(helpMessages.get("add -l"));
            System.out.println(helpMessages.get("add -d"));
            break;

        case "delete":
        case "delete -a":
        case "delete -e":
        case "delete -h":
        case "delete -r":
            System.out.println(helpMessages.get("delete"));
            System.out.println(helpMessages.get("delete -a"));
            System.out.println(helpMessages.get("delete -e"));
            System.out.println(helpMessages.get("delete -h"));
            System.out.println(helpMessages.get("delete -r"));
            break;

        case "update":
            System.out.println(helpMessages.get("update"));
            break;

        case "exit":
            System.out.println(helpMessages.get("exit"));
            break;

        default:
            System.out.println("Unknown command. Please use 'help <command>' for assistance.");
            break;
        }
    }
}


[java/command/UpdateCommand.java]:

package seedu.command;

import seedu.exceptions.InventraException;
import seedu.exceptions.InventraExcessArgsException;
import seedu.exceptions.InventraInvalidFlagException;
import seedu.exceptions.InventraInvalidHeaderException;
import seedu.exceptions.InventraInvalidNumberException;
import seedu.exceptions.InventraInvalidTypeException;
import seedu.exceptions.InventraLessArgsException;
import seedu.exceptions.InventraMissingArgsException;
import seedu.exceptions.InventraOutOfBoundsException;
import seedu.model.Inventory;
import seedu.storage.Csv;
import seedu.ui.Ui;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UpdateCommand extends Command {
    public UpdateCommand(Inventory inventory, Ui ui, Csv csv) {
        super(inventory, ui, csv);
    }

    public void execute(String[] args) throws InventraException {
        if (args.length < 2) {
            throw new InventraMissingArgsException("Flag or update details");
        }
        String flag = args[1];
        switch (flag) {
        case "-d":
            if (args.length < 3) {
                throw new InventraMissingArgsException("update " +
                        "-d <id>, <fieldname>, <newvalue>");
            }
            handleUpdateRecord(args[2]);
            csv.updateCsv(inventory);
            break;
        case "-h":
            if (args.length < 3) {
                throw new InventraMissingArgsException("update -h <old>, <new>");
            }
            handleUpdateField(args[2]);
            csv.updateCsvHeaders(inventory);
            break;
        default:
            throw new InventraInvalidFlagException("Use 'update -d <id>, " +
                    "<field_name>, <new value>' or 'update -h <old header name> <new header name>'");
        }
    }

    private void handleUpdateField(String fieldData) throws InventraException {
        String[] fields = fieldData.split(",\\s*");

        if (fields.length > 2) {
            throw new InventraExcessArgsException(2, fields.length);
        } else if (fields.length < 2) {
            throw new InventraLessArgsException(2, fields.length);
        }

        String oldFieldName = fields[0].trim();
        String newFieldName = fields[1].trim();

        if (oldFieldName.isEmpty() || newFieldName.isEmpty()) {
            throw new InventraInvalidTypeException("Field names",
                    "cannot be empty or just spaces", "provide valid field names");
        }

        if (oldFieldName.length() > 20 || newFieldName.length() > 20) {
            throw new InventraInvalidTypeException("Field name length",
                    "exceeds 20 characters", "use shorter names");
        }

        if (!isFieldValid(oldFieldName)) {
            throw new InventraInvalidHeaderException(oldFieldName);
        }

        List<String> updatedFields = updateFields(oldFieldName, newFieldName);
        Map<String, String> updatedFieldTypes = updateFieldTypes(oldFieldName, newFieldName);
        List<Map<String, String>> updatedRecordsForHeaderChange =
                updateRecordsForHeaderChange(oldFieldName, newFieldName);

        inventory.setFields(updatedFields);
        inventory.setFieldTypes(updatedFieldTypes);
        inventory.setRecords(updatedRecordsForHeaderChange);
    }

    private List<String> updateFields(String oldFieldName, String newFieldName) {
        List<String> updatedFields = new ArrayList<>();
        List<String> oldFields = inventory.getFields();

        for (String field : oldFields) {
            if (field.equals(oldFieldName)) {
                updatedFields.add(newFieldName);
            } else {
                updatedFields.add(field);
            }
        }

        return updatedFields;
    }

    private Map<String, String> updateFieldTypes(String oldFieldName, String newFieldName) {
        Map<String, String> updatedFieldTypes = new HashMap<>();
        Map<String, String> oldFieldTypes = inventory.getFieldTypes();

        for (Map.Entry<String, String> entry : oldFieldTypes.entrySet()) {
            if (entry.getKey().equals(oldFieldName)) {
                updatedFieldTypes.put(newFieldName, entry.getValue());
            } else {
                updatedFieldTypes.put(entry.getKey(), entry.getValue());
            }
        }

        return updatedFieldTypes;
    }

    private List<Map<String, String>> updateRecordsForHeaderChange(String oldFieldName, String newFieldName) {
        List<Map<String, String>> oldRecords = this.inventory.getRecords();
        List<Map<String, String>> updatedRecords = new ArrayList<>();

        for (int l = 0; l < oldRecords.size(); l++) {
            Map<String, String> newRecordMap = new HashMap<>();
            Map<String, String> oldRecordMap = oldRecords.get(l);
            for (Map.Entry<String, String> entry : oldRecordMap.entrySet()) {
                if (oldFieldName.equals(entry.getKey())) {
                    newRecordMap.put(newFieldName, entry.getValue());
                } else {
                    newRecordMap.put(entry.getKey(), entry.getValue());
                }
            }

            updatedRecords.add(newRecordMap);
        }
        return updatedRecords;
    }

    private boolean isFieldValid(String oldFieldName) {
        List<String> fields = inventory.getFields();
        return fields.contains(oldFieldName);
    }

    private void handleUpdateRecord(String enteredString) throws InventraException {
        String[] userInputs = enteredString.split(",\\s*");

        if (userInputs.length != 3) {
            if (userInputs.length < 3) {
                throw new InventraLessArgsException(3, userInputs.length);  // Use InventraLessArgsException
            } else {
                throw new InventraExcessArgsException(3, userInputs.length);
            }
        }

        String indexNumberString = userInputs[0].trim();
        String fieldName = userInputs[1].trim();
        String newValue = userInputs[2].trim();

        if (indexNumberString.isEmpty() || fieldName.isEmpty() || newValue.isEmpty()) {
            throw new InventraInvalidTypeException("Inputs",
                    "cannot be empty or just spaces", "provide valid inputs");
        }

        int indexNumber = parseIndex(indexNumberString);

        if (indexNumber <= 0 || indexNumber > inventory.getRecords().size()) {
            throw new InventraOutOfBoundsException(indexNumber, 1, inventory.getRecords().size());
        }

        if (!isFieldValid(fieldName)) {
            throw new InventraInvalidHeaderException(fieldName);
        }

        String type = inventory.getFieldTypes().get(fieldName);
        String validationMessage = validateValue(newValue, type, fieldName);
        if (validationMessage != null) {
            ui.showValidationError(validationMessage);
        }

        List<Map<String, String>> updatedRecords = updateRecords(indexNumber, fieldName, newValue);

        this.inventory.setRecords(updatedRecords);
    }

    private List<Map<String, String>> updateRecords(
            int indexNumber,
            String fieldName,
            String newValue
    ) throws InventraOutOfBoundsException {
        List<Map<String, String>> oldRecords = this.inventory.getRecords();
        List<Map<String, String>> updatedRecords = new ArrayList<>();

        for (int l = 0; l < oldRecords.size(); l++) {
            Map<String, String> newRecordMap = new HashMap<>();
            Map<String, String> oldRecordMap = oldRecords.get(l);

            if (l == (indexNumber - 1)) { //adjusting for user input index and stored index
                for (Map.Entry<String, String> entry : oldRecordMap.entrySet()) {
                    if (fieldName.equals(entry.getKey())) {
                        newRecordMap.put(entry.getKey(), newValue);
                    } else {
                        newRecordMap.put(entry.getKey(), entry.getValue());
                    }
                }
            } else {
                newRecordMap.putAll(oldRecordMap);
            }

            updatedRecords.add(newRecordMap);
        }
        return updatedRecords;
    }

    private String validateValue(String value, String type, String field) throws InventraException {
        assert value != null && !value.isEmpty() : "Value should not be null or empty";
        assert type != null && !type.isEmpty() : "Field type should not be null or empty";
        assert field != null && !field.isEmpty() : "Field name should not be null or empty";

        switch (type) {
        case "s": // String
            return null; // Any string is valid
        case "i": // Integer
            try {
                Integer.parseInt(value);
                return null; // Valid integer
            } catch (NumberFormatException e) {
                throw new InventraInvalidTypeException(field, value, type);
            }
        case "f": // Float
            try {
                Float.parseFloat(value);
                return null; // Valid float
            } catch (NumberFormatException e) {
                throw new InventraInvalidTypeException(field, value, type);
            }
        case "d": // Date
            String[] parts = value.split("/");
            if (parts.length != 3) {
                throw new InventraInvalidTypeException(field, value, type);
            }
            try {
                int day = Integer.parseInt(parts[0]);
                int month = Integer.parseInt(parts[1]);
                int year = Integer.parseInt(parts[2]);
                if (day <= 0 || month <= 0 || month > 12 || year < 0) {
                    throw new InventraInvalidTypeException(field, value, type);
                }
                return null; // Valid date
            } catch (NumberFormatException e) {
                throw new InventraInvalidTypeException(field, value, type);
            }
        case "n": // Null
            if (!value.equalsIgnoreCase("null")) {
                throw new InventraInvalidTypeException(field, value, type);
            }
            return null; // Valid null
        default:
            return ui.getUnknownTypeMessage(field);
        }
    }

    private int parseIndex(String indexString) throws InventraInvalidNumberException {
        try {
            return Integer.parseInt(indexString);
        } catch (NumberFormatException e) {
            throw new InventraInvalidNumberException(indexString);
        }
    }
}


[java/command/ViewCommand.java]:

package seedu.command;

import seedu.exceptions.InventraException;
import seedu.exceptions.InventraExcessArgsException;
import seedu.exceptions.InventraInvalidNumberException;
import seedu.exceptions.InventraMissingArgsException;
import seedu.exceptions.InventraOutOfBoundsException;
import seedu.model.Inventory;
import seedu.ui.Ui;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class ViewCommand extends Command {

    public ViewCommand(Inventory inventory, Ui ui) {
        super(inventory, ui, null);  // Passing `null` for unused dependencies
    }

    public void execute(String[] args) throws InventraException {
        if (args.length < 2) {
            throw new InventraMissingArgsException("Flag or Item index");
        }

        String flag = args[1].trim();
        switch (flag) {
        case "-f":
            handleViewByKeyword(args);
            break;

        case "-a":
            if (args.length > 2) {
                throw new InventraExcessArgsException(2, args.length);
            }
            ui.showFieldsAndRecords(inventory); // View all items
            break;

        default:
            if (args.length > 2) {
                throw new InventraExcessArgsException(2, args.length);
            }
            handleViewById(flag);
            break;
        }
    }

    private void handleViewById(String input) throws InventraException {
        if (input.trim().isEmpty()) {
            throw new InventraMissingArgsException("Item index");
        }

        try {
            int id = Integer.parseInt(input);

            // Validate the provided ID
            if (id <= 0 || id > inventory.getRecords().size()) {
                throw new InventraOutOfBoundsException(id, 1, inventory.getRecords().size());
            }

            // Extract and display the specific record (adjust 1-based index to 0-based)
            Map<String, String> record = inventory.getRecords().get(id - 1);
            ui.showSingleRecordWithOriginalId(inventory.getFields(), record, id);
        } catch (NumberFormatException e) {
            throw new InventraInvalidNumberException(input);
        }
    }

    private void handleViewByKeyword(String[] args) throws InventraException {
        if (args.length < 3 || args[2].trim().isEmpty()) {
            throw new InventraMissingArgsException("Keyword for filtering");
        }

        String keyword = String.join(" ",
                java.util.Arrays.copyOfRange(args, 2, args.length)).toLowerCase();

        List<Map<String, String>> records = inventory.getRecords();
        List<Map<String, String>> matchingRecords = new ArrayList<>();

        for (Map<String, String> record : records) {
            for (String field : record.keySet()) {
                if (inventory.isStringField(field) && record.get(field).toLowerCase().contains(keyword)) {
                    matchingRecords.add(record);
                    break;
                }
            }
        }

        if (!matchingRecords.isEmpty()) {
            ui.printMessage("Here are the records that match the keyword:");
            ui.showFieldsAndRecords(inventory.getFields(), matchingRecords);
        } else {
            ui.printMessage("Sorry, there are no records that match the keyword.");
        }
    }
}


[java/exceptions/InventraException.java]:

package seedu.exceptions;

public class InventraException extends Exception {
    @Override
    public String getMessage() {
        return "Error: An error has occurred";
    }
}


[java/exceptions/InventraExcessArgsException.java]:

package seedu.exceptions;

public class InventraExcessArgsException extends InventraException {
    private final int expected;
    private final int actual;

    public InventraExcessArgsException(int expected, int actual) {
        this.expected = expected;
        this.actual = actual;
    }

    public String getMessage() {
        return "Error: More arguments than required, expected: " + expected + ", received " + actual;
    }
}


[java/exceptions/InventraInvalidCommandException.java]:

package seedu.exceptions;

public class InventraInvalidCommandException extends InventraException {
    private final String command;

    public InventraInvalidCommandException(String command) {
        this.command = command;
    }

    @Override
    public String getMessage() {
        return "Error: The command '" + command + "' is invalid. Type help to receive valid commands";
    }
}



[java/exceptions/InventraInvalidFlagException.java]:

package seedu.exceptions;

public class InventraInvalidFlagException extends InventraException {
    private final String message;

    public InventraInvalidFlagException(String message) {
        this.message = message;
    }

    @Override
    public String getMessage() {
        return "Error: Invalid flags used\n" + message;
    }
}


[java/exceptions/InventraInvalidHeaderException.java]:

package seedu.exceptions;

public class InventraInvalidHeaderException extends InventraException {
    private final String headerName;

    public InventraInvalidHeaderException(String headerName) {
        this.headerName = headerName;
    }

    public String getMessage() {
        return "Error: " + headerName + " does not exist";
    }
}


[java/exceptions/InventraInvalidNumberException.java]:

package seedu.exceptions;

public class InventraInvalidNumberException extends InventraException {
    private final String invalidNumber;

    public InventraInvalidNumberException(String input) {
        invalidNumber = input;
    }

    @Override
    public String getMessage() {
        return String.format("Error: The input %s could not be parsed as an integer.", invalidNumber);
    }
}


[java/exceptions/InventraInvalidRecordCountException.java]:

package seedu.exceptions;

public class InventraInvalidRecordCountException extends InventraException {
    private final int expectedCount;
    private final int actualCount;

    public InventraInvalidRecordCountException(int expectedCount, int actualCount) {
        this.expectedCount = expectedCount;
        this.actualCount = actualCount;
    }

    @Override
    public String getMessage() {
        return "Error: Invalid number of values.\n" +
                "Expected " + expectedCount + " values, but got " + actualCount + ".";
    }
}


[java/exceptions/InventraInvalidTypeException.java]:

package seedu.exceptions;

public class InventraInvalidTypeException extends InventraException {
    private final String field;
    private final String input;
    private final String expectedType;

    public InventraInvalidTypeException(String field, String input, String expectedType) {
        this.field = field;
        this.input = input;
        this.expectedType = expectedType;
    }

    @Override
    public String getMessage() {
        return "Error: Invalid type for field '" + field + "'\n" +
                "Expected value of type '" + expectedType + "', got: '" + input + "'";
    }
}


[java/exceptions/InventraLessArgsException.java]:

package seedu.exceptions;

public class InventraLessArgsException extends InventraException {
    private final int expected;
    private final int actual;

    public InventraLessArgsException(int expected, int actual) {
        this.expected = expected;
        this.actual = actual;
    }

    public String getMessage() {
        return "Error: Less arguments than required, expected: " + expected + ", received " + actual;
    }
}


[java/exceptions/InventraMissingArgsException.java]:

package seedu.exceptions;

public class InventraMissingArgsException extends InventraException {
    private final String[] args;

    public InventraMissingArgsException(String... args) {
        this.args = args;
    }

    @Override
    public String getMessage() {
        return "Error: Missing the following arguments: " + String.join(", ", args);
    }
}


[java/exceptions/InventraMissingFieldsException.java]:

package seedu.exceptions;

public class InventraMissingFieldsException extends InventraException {
    @Override
    public String getMessage() {
        return "Error: Inventory is missing fields\nUse 'add -h <s/pname, i/quantity, ...>' to add fields.";
    }
}


[java/exceptions/InventraNegativeValueException.java]:

package seedu.exceptions;

public class InventraNegativeValueException extends InventraException {
    private final String field;

    public InventraNegativeValueException(String field, String value) {
        super();
        this.field = field;
    }

    @Override
    public String getMessage() {
        return "Error: Negative value detected in field '" + field + "'. Value must be non-negative.";
    }
}


[java/exceptions/InventraOutOfBoundsException.java]:

package seedu.exceptions;

public class InventraOutOfBoundsException extends InventraException {
    private final int provided;
    private final int min;
    private final int max;

    public InventraOutOfBoundsException(int provided, int min, int max) {
        this.provided = provided;
        this.min = min;
        this.max = max;
    }

    @Override
    public String getMessage() {
        return String.format("Error: ID %d is out of bounds. Valid range is between %d and %d.", provided, min, max);
    }
}


[java/inventra/Inventra.java]:

package seedu.inventra;

import seedu.model.Inventory;
import seedu.ui.Ui;
import seedu.storage.Csv;

public class Inventra {
    public static void main(String[] args) {
        Ui ui = new Ui();
        Inventory inventory = new Inventory(); // Instantiate Inventory here
        Csv csv = new Csv("data/inventory.csv");

        // Load existing records from CSV
        csv.loadInventoryFromCsv(inventory);
        ui.run(inventory, csv);
    }
}


[java/model/Inventory.java]:

package seedu.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Inventory {
    private List<String> fields;
    private Map<String, String> fieldTypes; // Map field <-> type
    private List<Map<String, String>> records; // List of mapped field <-> record


    public Inventory() {
        this.fields = new ArrayList<>();
        this.fieldTypes = new HashMap<>();
        this.records = new ArrayList<>();
    }

    public Inventory(List<String> fields, Map<String, String> fieldTypes, List<Map<String, String>> records) {
        this.fields = fields;
        this.fieldTypes = fieldTypes;
        this.records = records;
    }
    public void addField(String field, String type) {
        fields.add(field);
        fieldTypes.put(field, type);
    }

    public List<String> getFields() {
        return fields;
    }

    public Map<String, String> getFieldTypes() {
        return fieldTypes;
    }

    public void addRecord(Map<String, String> record) {
        records.add(record);
    }

    public List<Map<String, String>> getRecords() {
        return records;
    }

    public void setRecords(List<Map<String, String>> records) {
        this.records = records;
    }

    // Method to set fields (for loading from CSV)
    public void setFields(List<String> fields) {
        this.fields = fields;
    }

    public void setFieldTypes(Map<String, String> newFieldTypes) {
        this.fieldTypes = newFieldTypes;
    }

    public boolean isStringField(String fieldName) {
        return "s".equals(fieldTypes.get(fieldName));  // "s" denotes a String type field
    }
}


[java/parser/CommandParser.java]:

package seedu.parser;

import seedu.command.ViewCommand;
import seedu.command.HelpCommand;
import seedu.command.AddCommand;
import seedu.command.DeleteCommand;
import seedu.command.UpdateCommand;
import seedu.exceptions.InventraException;
import seedu.exceptions.InventraExcessArgsException;
import seedu.exceptions.InventraInvalidCommandException;
import seedu.model.Inventory;
import seedu.ui.Ui;
import seedu.storage.Csv;

public class CommandParser {
    public static void parseCommand(String input, Inventory inventory, Ui ui, Csv csv) {
        // Normalize input by trimming
        input = input.trim().replaceAll("\\s+", " ");

        String[] parts = input.split(" ", 3);
        String command = parts[0];

        try {
            switch (command) {
            case "add":
                new AddCommand(inventory, ui, csv).execute(parts);
                break;
            case "delete":
                new DeleteCommand(inventory, ui, csv).execute(parts);
                break;
            case "update":
                new UpdateCommand(inventory, ui, csv).execute(parts);
                break;
            case "view":
                new ViewCommand(inventory, ui).execute(parts);
                break;
            case "help":
                new HelpCommand(ui).execute(parts);
                break;
            case "exit":
                if (parts.length > 1) {
                    throw new InventraExcessArgsException(1, parts.length);
                }
                ui.printMessage("Program exit successfully.");
                break;
            default:
                throw new InventraInvalidCommandException(command);
            }
        } catch (InventraException e) {
            System.out.println(e.getMessage());
        }
    }
}


[java/storage/Csv.java]:

package seedu.storage;

import seedu.model.Inventory;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Csv {

    private final String csvFilePath;

    public Csv(String relativeCsvFilePath) {
        this.csvFilePath = relativeCsvFilePath;
        ensureParentDirectoriesExist(); // Ensure the directory exists
        ensureFileExists();
    }

    // Ensure the directory exists
    private void ensureParentDirectoriesExist() {
        File file = new File(csvFilePath);
        File parentDir = file.getParentFile(); // Get the parent directory
        if (parentDir != null && !parentDir.exists()) {
            if (parentDir.mkdirs()) {
                System.out.println("Directory created: " + parentDir.getName());
            } else {
                System.err.println("Failed to create directory: " + parentDir.getName());
            }
        }
    }

    private void ensureFileExists() {
        File file = new File(csvFilePath);
        try {
            if (file.createNewFile()) {
                System.out.println("File created: " + file.getName());
            }
        } catch (IOException e) {
            System.err.println("Failed to create file: " + e.getMessage());
        }
    }

    public void updateCsvAfterDeletion(Inventory inventory) {
        List<String> fields = inventory.getFields();
        Map<String, String> fieldTypes = inventory.getFieldTypes();

        // Create the metadata line from field types
        List<String> metadata = new ArrayList<>();
        for (String field : fields) {
            String type = fieldTypes.get(field);
            metadata.add(field + ":" + type);
        }
        String metadataLine = "#" + String.join(",", metadata);

        try (FileWriter writer = new FileWriter(csvFilePath, false)) {
            // Write the metadata line first
            writer.append(metadataLine).append("\n");

            // Write field names (headers)
            if (!fields.isEmpty()) {
                writer.append(String.join(",", fields)).append("\n");
            }

            // Handle records
            for (Map<String, String> record : inventory.getRecords()) {
                for (int i = 0; i < fields.size(); i++) {
                    String field = fields.get(i);
                    String value = record.getOrDefault(field, "null");
                    writer.append(value != null ? value : "null");
                    if (i < fields.size() - 1) {
                        writer.append(",");
                    }
                }
                writer.append("\n");
            }
            System.out.println("CSV file updated after deletion, including metadata.");
        } catch (IOException e) {
            System.err.println("Error updating CSV after deletion: " + e.getMessage());
        }
    }

    // Update the CSV file headers and keep the existing data
    public void updateCsvHeaders(Inventory inventory) {
        List<String> fields = inventory.getFields();
        Map<String, String> fieldTypes = inventory.getFieldTypes();

        // metadata include for persistent field type
        List<String> metadata = new ArrayList<>();
        for (String field : fields) {
            String type = fieldTypes.get(field);
            metadata.add(field + ":" + type);
        }
        String metadataLine = "#" + String.join(",", metadata);

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(csvFilePath))) {
            // Write metadata line
            writer.write(metadataLine);
            writer.newLine();
            // Write header line (field names)
            writer.write(String.join(",", fields));
            writer.newLine();
            // Write data records
            for (Map<String, String> record : inventory.getRecords()) {
                List<String> values = new ArrayList<>();
                for (String field : fields) {
                    values.add(record.getOrDefault(field, ""));
                }
                writer.write(String.join(",", values));
                writer.newLine();
            }
            System.out.println("CSV file header updated.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Append a record to the CSV file considering the field order
    public void appendRecord(Map<String, String> record, Inventory inventory) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(csvFilePath, true))) {
            List<String> values = new ArrayList<>();
            for (String field : inventory.getFields()) {
                values.add(record.getOrDefault(field, ""));
            }
            writer.write(String.join(",", values));
            writer.newLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Load records from the CSV file into the Inventory
    public void loadInventoryFromCsv(Inventory inventory) {
        File file = new File(csvFilePath);
        if (file.length() == 0) {
            // No data to load, fresh file
            return;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;

            // Read field definitions from the metadata header (first line starting with #)
            if ((line = reader.readLine()) != null && line.startsWith("#")) {
                String metadata = line.substring(1);  // Remove the # character
                String[] fieldsWithTypes = metadata.split(",\\s*");
                List<String> fields = new ArrayList<>();
                Map<String, String> fieldTypes = new HashMap<>();

                for (String fieldType : fieldsWithTypes) {
                    String[] parts = fieldType.trim().split(":");
                    if (parts.length == 2) {
                        String fieldName = parts[0].trim();
                        String type = parts[1].trim();
                        fields.add(fieldName);
                        fieldTypes.put(fieldName, type);
                    } else {
                        //System.out.println("Invalid field type definition: " + fieldType);
                        return;
                    }
                }

                inventory.setFields(fields);
                inventory.setFieldTypes(fieldTypes);
                //System.out.println("Fields loaded from CSV: " + fields);
                //System.out.println("Field types loaded from CSV: " + fieldTypes);
            } else {
                System.out.println("CSV file format error: Missing metadata header.");
                return;
            }

            // Read headers (second line)
            if ((line = reader.readLine()) != null) {
                String[] headers = line.split(",");
                //System.out.println("Column headers: " + String.join(", ", headers));
            }

            // Read records (remaining lines)
            while ((line = reader.readLine()) != null) {
                String[] values = line.split(",");
                Map<String, String> record = new HashMap<>();

                List<String> fields = inventory.getFields();
                for (int i = 0; i < values.length; i++) {
                    if (i < fields.size()) {
                        String field = fields.get(i).trim();
                        String value = values[i].trim();
                        record.put(field, value);
                    }
                }

                inventory.addRecord(record);
                //System.out.println("Record added: " + record);
            }

            System.out.println("Finished loading CSV file.");
        } catch (IOException e) {
            System.out.println("Error reading CSV file: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void updateCsv(Inventory inventory) {
        List<String> fields = inventory.getFields();
        Map<String, String> fieldTypes = inventory.getFieldTypes();

        // Create the metadata line from field types
        List<String> metadata = new ArrayList<>();
        for (String field : fields) {
            String type = fieldTypes.get(field);
            metadata.add(field + ":" + type);
        }
        String metadataLine = "#" + String.join(",", metadata);

        try (FileWriter writer = new FileWriter(csvFilePath, false)) {
            // Write the metadata line first
            writer.append(metadataLine).append("\n");

            // Write field names (headers)
            if (!fields.isEmpty()) {
                writer.append(String.join(",", fields)).append("\n");
            }

            // Handle records
            for (Map<String, String> record : inventory.getRecords()) {
                for (int i = 0; i < fields.size(); i++) {
                    String field = fields.get(i);
                    String value = record.getOrDefault(field, "null");
                    writer.append(value != null ? value : "null");
                    if (i < fields.size() - 1) {
                        writer.append(",");
                    }
                }
                writer.append("\n");
            }
            System.out.println("CSV file updated.");
        } catch (IOException e) {
            System.err.println("Error updating CSV: " + e.getMessage());
        }
    }
}


[java/ui/Concat.java]:

package seedu.ui;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

public class Concat {

    // Set this relative path to match your project structure
    private static final String SOURCE_DIRECTORY = "src/main/java/seedu";
    private static final String OUTPUT_FILE = "allJavaCode.txt";

    public static void main(String[] args) {
        System.out.println("Checking directory: " + SOURCE_DIRECTORY); // Debugging output
        File directory = new File(SOURCE_DIRECTORY);

        if (!directory.exists()) {
            System.out.println("Directory does not exist: " + directory.getAbsolutePath());
            return;
        } else if (!directory.isDirectory()) {
            System.out.println("Not a directory: " + directory.getAbsolutePath());
            return;
        }

        try (FileWriter writer = new FileWriter(OUTPUT_FILE, true)) {
            appendJavaFiles(directory, writer);
            System.out.println("All Java code has been appended to " + OUTPUT_FILE);
        } catch (IOException e) {
            System.err.println("An error occurred while writing to the file: " + e.getMessage());
        }
    }

    private static void appendJavaFiles(File dir, FileWriter writer) throws IOException {
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    appendJavaFiles(file, writer); // Recursively search subdirectories
                } else if (file.isFile() && file.getName().endsWith(".java")) {
                    appendFileContent(file, writer);
                }
            }
        }
    }

    private static void appendFileContent(File file, FileWriter writer) throws IOException {
        String filePath = file.getPath().replace("\\", "/").replace(SOURCE_DIRECTORY, "java");
        writer.write("[" + filePath + "]:\n\n");

        List<String> lines = Files.readAllLines(Paths.get(file.getPath()));
        for (String line : lines) {
            writer.write(line + "\n");
        }
        writer.write("\n\n"); // Add space between files
    }
}


[java/ui/Ui.java]:

package seedu.ui;

import seedu.model.Inventory;
import seedu.parser.CommandParser;
import seedu.storage.Csv;

import java.util.Map;
import java.util.List;
import java.util.Scanner;

public class Ui {

    public void printGreeting() {
        String logo = " ___ _   ___     _______ _   _ _____ ____      _    \n"
                + "|_ _| \\ | \\ \\   / / ____| \\ | |_   _|  _ \\    / \\   \n"
                + " | ||  \\| |\\ \\ / /|  _| |  \\| | | | | |_) |  / _ \\  \n"
                + " | || |\\  | \\ V / | |___| |\\  | | | |  _ <  / ___ \\ \n"
                + "|___|_| \\_|  \\_/  |_____|_| \\_| |_| |_| \\_\\/_/   \\_\\\n";
        printMessage("Welcome to\n" + logo);
        printMessage("Type help to receive manual.");
    }

    public void run(Inventory inventory, Csv csv) {
        Scanner in = new Scanner(System.in);
        printGreeting();
        String input;
        do {
            input = in.nextLine().trim();  // Trim input to handle accidental spaces
            if (input.isEmpty()) {
                continue;  // Skip empty input lines
            }
            System.out.println("_____________________________________________");
            CommandParser.parseCommand(input, inventory, this, csv);
            System.out.println("_____________________________________________");
        } while (!input.equals("exit"));
    }

    public void printMessage(String message) {
        System.out.println(message);
    }

    public void printSingleRecord(Map<String, String> record, int id) {
        printMessage("Record ID: " + id);
        for (Map.Entry<String, String> entry : record.entrySet()) {
            printMessage(entry.getKey() + ": " + entry.getValue());
        }
    }

    public void printViewHelp() {
        printMessage("Use [view -a] to view all records, or [view <ID>] to view individual record");
    }


    // Show fields and records in table format for the full inventory
    public void showFieldsAndRecords(Inventory inventory) {
        List<String> fields = inventory.getFields();
        List<Map<String, String>> records = inventory.getRecords();
        showFieldsAndRecords(fields, records);
    }

    // Show fields and specific records in table format
    public void showFieldsAndRecords(List<String> fields, List<Map<String, String>> records) {
        if (fields.isEmpty()) {
            printMessage("    No fields have been added yet.");
            return;
        }

        printTableHeader(fields);

        if (records.isEmpty()) {
            printMessage("    No records have been added yet.");
        } else {
            printTableRecords(fields, records);
        }
    }

    public void showSingleRecordWithOriginalId(List<String> fields, Map<String, String> record, int actualId) {
        StringBuilder header = new StringBuilder("    +");
        StringBuilder row = new StringBuilder("    | ");
        row.append(String.format("%-5d | ", actualId));  // Add correct ID

        for (String field : fields) {
            header.append("-".repeat(Math.max(field.length(), 20) + 2)).append("+");
            String value = record.getOrDefault(field, "null");
            row.append(String.format("%-20s | ", value));
        }
        printMessage(header.toString());
        printMessage(row.toString());
        printMessage(header.toString());
    }

    // Prints table header with fields and adds the "ID" column
    private void printTableHeader(List<String> fields) {
        StringBuilder header = new StringBuilder("    | ");
        StringBuilder separator = new StringBuilder("    +");

        // Add the "ID" column header
        int idColumnWidth = 5;  // Fixed width for ID column
        header.append(String.format("%-" + idColumnWidth + "s | ", "ID"));
        separator.append("-".repeat(idColumnWidth + 2)).append("+");

        // Add the other field headers
        for (String field : fields) {
            int columnWidth = Math.max(field.length(), 20);  // Ensure minimum column width of 20
            header.append(String.format("%-" + columnWidth + "s | ", field));  // Left-align the field names
            separator.append("-".repeat(columnWidth + 2)).append("+");  // Add separator line below header
        }

        printMessage(separator.toString());
        printMessage(header.toString());
        printMessage(separator.toString());
    }


    // Prints table rows with records and adds the "ID" column
    private void printTableRecords(List<String> fields, List<Map<String, String>> records) {
        StringBuilder separator = new StringBuilder("    +");

        // Fixed width for ID column
        int idColumnWidth = 5;
        separator.append("-".repeat(idColumnWidth + 2)).append("+");

        // Add the separator for the other fields
        for (String field : fields) {
            int columnWidth = Math.max(field.length(), 20);  // Ensure minimum column width of 20
            separator.append("-".repeat(columnWidth + 2)).append("+");
        }

        // Print the rows
        int id = 1;  // Start ID at 1
        for (Map<String, String> record : records) {
            StringBuilder row = new StringBuilder("    | ");

            // Print ID (fixed width of 5 characters)
            row.append(String.format("%-" + idColumnWidth + "d | ", id));
            id++;  // Increment ID for the next row

            // Print the other field values
            for (String field : fields) {
                int columnWidth = Math.max(field.length(), 20);  // Ensure minimum column width of 20
                String value = record.getOrDefault(field, "null");  // Handle missing values
                row.append(String.format("%-" + columnWidth + "s | ", value));  // Left-align values
            }

            printMessage(row.toString());
            printMessage(separator.toString());
        }
    }


    public void showSuccessFieldsAdded() {
        printMessage("    Fields added successfully.");
    }

    public void showSuccessRecordAdded() {
        printMessage("    Record added successfully.");
    }

    public void showValidationError(String message) {
        printMessage(message);
    }

    public String getUnknownTypeMessage(String field) {
        return "    Unknown field type for field '" + field + "'.";
    }
}


